/**
 * This is the bit of JS that gets injected via a bookmarklet and creates an
 * iframe communication bridge.  The iframe is currently just a way to bounce
 * messages across to a BroadcastChannel in the iframe's origin.
 */

import { BridgeServer } from './bridge/server.js';

// XXX figure out our port from scraping our bookmarklet script tag.
const PORT = 3333;
const ORIGIN = `http://localhost:${PORT}`


/**
 * Build an "executions of" query centered around the UI's current position in
 * the trace.  The query will be limited to `limit` results in events occurring
 * before and after the current position.
 */
function buildExecutionQuery({ symbol, print }, limit=50) {
  const queryFocus = Object.assign({}, window.client.focus);
  const focusMoment = queryFocus.moment;
  return [
    {
      focus: queryFocus,
      params: {
        symbol,
        print
      },
      limits: {
        startMoment: {
          event: 0,
          instr: 0,
        },
        startOffset: 0,
        endMoment: focusMoment,
        endOffset: 1125899906842624,
        direction: 'backward',
        lines: limit
      },
    },
    {
      focus: queryFocus,
      params: {
        symbol,
        print
      },
      limits: {
        startMoment: focusMoment,
        startOffset: 1125899906842624,
        endMoment: {
          event: 1125899906842624,
          instr: 1125899906842624,
        },
        endOffset: 1125899906842624,
        direction: 'forward',
        lines: limit
      },
    },
  ];
}

/**
 * Build a query defaulting to being evaluated at the current position in the
 * trace.
 */
function buildSimpleQuery(mixArgs) {
  const queryFocus = Object.assign({}, window.client.focus);
  return Object.assign({
    focus: queryFocus,
  }, mixArgs);
}

/**
 * Handler that just waits for all the results to come in, then resolves its
 * promise.
 *
 * Things done/not done:
 * - activeQueryCount - Not present, avoiding element manipulation.
 */
class BatchHandler {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });

    this.results = [];
  }

  onData(id, data) {
    this.results.push(data);
  }

  onClose(id, hasNoMore, noResults) {
    this._resolve(this.results);
  }

  /**
   * Invoked when a disconnection occurs.  This allows queries to be reissued
   * when a reconnection occurs.  If we wanted that, we could have the handler
   * latch the query creation values and have it reset its results herein and
   * reissue the query with this self-same handler.
   *
   * However, everything is a big hack right now, and I'd rather avoid
   * generating accidental load against the pernosco servers, so let's just
   * reject in the case a disconnection occurs.
   */
  onDisconnected(id) {
    this._reject('disconnected');
  }
}

class POCServer extends BridgeServer {
  constructor(iframe) {
    super({ roleType: 'server', win: window, iframe });

    this.pclient = window.client;
  }

  /**
   * Simple wrapper around Client.openQuery to make sure we pass `{ api: 1 }` in
   * the options dictionary so that it's possible to distinguish calls via this
   * hack from queries generated by the pernosco UI itself.
   */
  _openQuery(name, req, handler) {
    return this.pclient.openQuery(name, req, handler, { api: 1 });
  }

  async onMsg_simpleQuery({ name, mixArgs }, reply) {
    console.log('poc: processing simple query for', name);
    let queryId;
    try {
      const req = buildSimpleQuery(mixArgs);
      const handler = new BatchHandler();
      queryId = this.pclient.openQuery(name, req, handler);
      const results = await handler.promise;
      queryId = null;

      reply(results)
    } finally {
      if (queryId) {
        this.pclient.cancelQuery(queryId);
      }
    }
  }

  async onMsg_executionQuery({ symbol, print }, reply) {
    console.log('poc: processing execution query for', symbol);
    let beforeQueryId, afterQueryId;
    try {
      const [beforeReq, afterReq] = buildExecutionQuery({ symbol, print });
      const beforeHandler = new BatchHandler();
      beforeQueryId = this._openQuery('execution', beforeReq, beforeHandler);

      const afterHandler = new BatchHandler();
      afterQueryId = this._openQuery('execution', afterReq, afterHandler);

      const beforeResults = await beforeHandler.promise;
      beforeQueryId = null;
      const afterResults = await afterHandler.promise;
      afterQueryId = null;

      const results = [...beforeResults, ...afterResults];

      reply(results);
    } finally {
      // Ensure we always terminate the query on the way out if initialized and
      // we're not sure it closed.
      if (beforeQueryId) {
        this.pclient.cancelQuery(beforeQueryId);
      }
      if (afterQueryId) {
        this.pclient.cancelQuery(afterQueryId);
      }
    }
  }
}


// Sorta idempotently create the iframe.
let bridgeFrame = document.getElementById('pt-poc-bridge-frame');
if (!bridgeFrame) {
  bridgeFrame = document.createElement('iframe');
  bridgeFrame.setAttribute('id', 'pt-poc-bridge-frame');
  bridgeFrame.setAttribute('style', 'display: none;');
  bridgeFrame.setAttribute('src', `${ORIGIN}/bridge.html`);
  document.body.appendChild(bridgeFrame);
} else {
  bridgeFrame.bridge.cleanup();
  window.removeEventListener('message', bridgeFrame.msgHandler);
}

bridgeFrame.bridge = new POCServer(bridgeFrame);
